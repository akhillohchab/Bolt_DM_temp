package edu.columbia.bolt.commondata;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeSet;


import com.sri.bolt.message.BoltMessages.AnswerMergerOperationType;

import edu.columbia.bolt.dmdata.DialogueEntry;
import edu.columbia.bolt.logging.Log;
import edu.columbia.bolt.util.NLPutil;

/**
 * This is the class passed to columbia's BOLT components
 * Each component reads data and writes ouptut to this class
 * The data includes word-level and utterance-level features
 * Word-level feature values are stored in lists. 
 * Each word feature value list is of length m_numWords
 * 
 * 
 * @author sveta
 *
 */
public class SentenceData {	
	
	//utterance type from protobuffer 
	/*OPERATION_USE_PREVIOUS_RESCORED = 0;
	  OPERATION_USE_LAST_RESCORED = 1;
	  OPERATION_ADD_ALT_MERGE_HYP = 2;
	  OPERATION_ADD_SPELLING = 3;
	  OPERATION_CHOOSE_EITHER_OR = 4;
	  OPERATION_CONFIRM_ERROR_SEGMENT_ATTRIBUTE = 5;
	  OPERATION_CONFIRM_UTTERANCE = 6;*/
	AnswerMergerOperationType answerMergerOperationType = null; 

	//ASR hypothesis rescored 
	String m_asrHypothesis = null;
	//AMU's merged hypothesis 
	String m_workingHypothesis = null;
	//pointers to the words where the utterance came from
	//pointerUtteranceIndex [i] is the index of the utterance where the word comes from
	//pointerWordIndex [i] is the index of the word where the word comes from
	
	//use this to get POS tags
	//throw exception if number of words in the m_workingHypothesis is not the same as in the list
	List<Integer> pointerUtteranceIndexWorkUtt = null;
	List<Integer> pointerWordIndexWorkUtt = null;
	
	//number of words in the sentence
	int m_numWords = 0;
	//words 
	List<String> m_wordsCurrentUtterance;
	//postags of the current utterance (used in conf scorer)
	List<String> m_postagsCurrentUtt;
	//words working utterance
	List<String> m_wordsWorkingUtt;
	//postags of the working utterance (used in DM)
	List<String> m_postagsWorkingUtt;
	//semantic roles
	List<String> m_oovTags;
	//dependency Tags
	List<String> m_dependancyTags;
	//dependency Links
	List<String> m_dependancyLinks;

	//asr confidence for each word
	List<Double> m_asrConfidence;
	//parse confidence for each word
	List<Double> m_parseConfidence;
	//probability of OOV for each word
	List<Double> m_oovConfidence;
	//probability of NE for each word
	List<Double> m_neConfidence;
	//probability of NE for each word
	List<Double> m_depConfidence;
	
	//duration of each word
	List<Double> m_duration;
	
	//prosodic features for each words
	Prosodics m_prosodicswords = new Prosodics();
	//prosodic features for the whole utterance
	Prosodics m_prosodicsutt = new Prosodics();
	
	//output generated by dialogue manager
	DialogueEntry m_dmEntry = null;
	//output of Classifier for words
	List<Double> m_cfConfidence;
	//output of Classifier for utterance
	Double m_uttConfidence;	
	
	//information on error segment, to be set by AMU and possibly by MT
	List<ErrorSegment> errorSegmentsFromAMU  = new ArrayList<ErrorSegment>();
	//this should be set on MessageWrapper to the index addressed in the previous utterance
	int m_addressErrorSegmentIndex = -1;
	
	//this should be set to true by SRI for the FIRST utterance in each set
	//boolean m_resetHistory = false;
	DialogueHistory m_dialogHistory = new DialogueHistory();
	
	//***********NLU data****************
	//TODO: this should eventually move to a separate package NLU. 
	//TODO class UserCommand{ double conf, bool confirmed}
	//at most one of the values can be set
	
	//when set to CONFIRM -> user has answered yes to a question "did you say UTT?"
	//when set to REJECT -> user has answered no to a question "did you say UTT?"
	ErrorSegment.UserFeedback userActionYesNo = ErrorSegment.UserFeedback.UNKNOWN;
	
	//when a user says go-back, set this to true.
	Boolean userActionGoBack = false;
	//*************************************
	
	Log m_log = new Log("SentenceData");
	
	public SentenceData(String asrHypothesis) {
		super();
		this.m_asrHypothesis = asrHypothesis;
		//m_log.setVerbose(1);
	}
	
	public SentenceData() {
		super();
		//m_log.setVerbose(1);
	}
	
	
	/**
	 * Construct an inputdata object using input parameters
	 * @param words
	 * @param postags
	 * @param semRole
	 * @param asrConfidence
	 * @param oovConfidence
	 * @param neConfidence
	 */
	public SentenceData(List<String> words, List<String> postags,
			List<String> oovTags, List<Double> asrConfidence,
			List<Double> oovConfidence, List<Double> neConfidence) throws SentenceDataException{
		super();
		this.setWordsCurrentUtt(words);
		this.setPostags(postags);
		this.setOovTags(oovTags);
		this.setAsrConfidence(asrConfidence);
		this.setOovConfidence(oovConfidence);
		this.setNeConfidence(neConfidence);		

	}
	

	
	/**
	 * 
	 * 
	 * @return 1 if number of errors >1 or if ratio of words in an error segment to the total number of words
	 */
	public double getRatioErrorWords(){
		if (m_numWords<=0) return 1;
		
		return (double)(getCurrentlyAddressedErrorSegment().getM_end() - getCurrentlyAddressedErrorSegment().getM_start() )/(double)pointerWordIndexWorkUtt.size() ;
	}
	
	/**
	 * get error segment that is currently addressed
	 */
	public ErrorSegment getCurrentlyAddressedErrorSegment(){
		//if currently addressed segment was not set, return null
		if(getM_addressErrorSegmentIndex()<0) 
			return null;
		if(errorSegmentsFromAMU.size()>getM_addressErrorSegmentIndex())
			return errorSegmentsFromAMU.get(getM_addressErrorSegmentIndex());
		else
			return null;
	}
	
	/**
	 * identify error segment that was addressed in the last utterance
	 * if this is a first utterance, return null
	 * @return 
	 */
	public ErrorSegment findPreviouslyAddressedError(DialogueHistory dialogueHistory){
		if(dialogueHistory.size()==0) return null;
		
		int indexOfPreviouslyAddressedError = dialogueHistory.getLastErrorAddressed();
		
		//if index is not set, that means no error was addressed 
		if(indexOfPreviouslyAddressedError<0) return null;
		
		//iterate through error segments to find the matching segment
		for(ErrorSegment errSeg: errorSegmentsFromAMU)
		{
			if(errSeg.getPreviousSegmentIndex()==indexOfPreviouslyAddressedError)
				return errSeg;
		}
		return null;
	}
	

	/**
	 * remove first error segement from the errorSegments list
	 * @return
	 *
	public void clearCurrentlyAddressedError(){
		if(errorSegmentsFromAMU.size()>getM_addressErrorSegmentIndex())
			errorSegmentsFromAMU.get(getM_addressErrorSegmentIndex()).setM_resolved(true);
	}*/
	
	/**
	 * find error according to the sorting function of the errorSegment compareTo
	 * take the top error as the first one
	 */
	public int chooseErrorToAddress(){
		if(errorSegmentsFromAMU.size()==0)
			return -1;
		
		TreeSet<ErrorSegment> sortedErrors = new TreeSet<ErrorSegment>(errorSegmentsFromAMU);
		
		//remove errors that have skip flag set
		while(sortedErrors.size()>0 && sortedErrors.first().isSkipFlag())
		{
			if(sortedErrors.first().isSkipFlag())
				sortedErrors.remove(sortedErrors.first());
		}
		
		if(sortedErrors.size()==0)
			return -1;
		
		int errorToAddress =  sortedErrors.first().getIndexInTheList();
		//m_log.print(1, "addressing error number " + errorToAddress );
		return errorToAddress;
		
/*		int maxIndex = -1;
		int maxScore = 0;
		for(int i = 0; i<errorSegmentsFromAMU.size(); i++)
		{
			//skip errors that were resolved
			if(errorSegmentsFromAMU.get(i).isAddressed())
				continue;
				
			if(errorSegmentsFromAMU.get(i).m_confErrorSegment>=maxScore)
				maxIndex = i;
		}
		
		return maxIndex;
*/		
	}
	
	/**
	 * return true if either there are no errors or all errors are cleared
	 * @return false if there are any unresolved errors
	 */
	public boolean areAllErrorsResolved(){
		if(errorSegmentsFromAMU.size()==0) return true;
		for (ErrorSegment errseg: errorSegmentsFromAMU)
		{
			if (!errseg.isM_resolved() ) return false;
		}
		return true;
		
	}
	
	/**
	 * return true if either there are no errors or all errors are cleared
	 * with confidence above threshold
	 * @return false if there are any unresolved errors
	 */
	public boolean areAllErrorsResolvedThreshold(double thresh){
		if(errorSegmentsFromAMU.size()==0) return true;
		for (ErrorSegment errseg: errorSegmentsFromAMU)
		{
			if (!errseg.isM_resolved() && errseg.getM_resolvedConf()>=thresh) return false;
		}
		return true;
		
	}
	
	public List<String> getWordsCurrentUtt() {
		
		return m_wordsCurrentUtterance;
	}
	
	private void checkSize(List data) throws SentenceDataException{
		if(m_numWords==0) m_numWords = data.size();		
		else
			if(m_numWords!=data.size())
				throw new SentenceDataException(m_numWords, data.size());
	}

	public void setWordsCurrentUtt(List<String> words) throws SentenceDataException {
		
		checkSize(words);
		
		m_asrHypothesis = new String();
		for (int i = 0; i< words.size(); i++)			
			this.m_asrHypothesis += words.get(i) + " ";
		this.m_wordsCurrentUtterance = words;
	}

	public List<String> getPostags() {
		return m_postagsCurrentUtt;
	}

	public void setPostags(List<String> postags) throws SentenceDataException {
		checkSize(postags);
		this.m_postagsCurrentUtt = postags;
	}

	public List<String> getOovTags() {
		return m_oovTags;
	}

	public void setOovTags(List<String> oovTag) throws SentenceDataException {
		checkSize(oovTag);
		this.m_oovTags = oovTag;
	}

	public List<Double> getAsrConfidence() {
		return m_asrConfidence;
	}
	
	public List<Double> getParseConfidence() {
		return m_parseConfidence;
	}

	public void setAsrConfidence(List<Double> asrConfidence) throws SentenceDataException {
		checkSize(asrConfidence);
		this.m_asrConfidence = asrConfidence;
	}
	
	public void setParseConfidence(List<Double> parseConfidence) throws SentenceDataException {
		checkSize(parseConfidence);
		this.m_parseConfidence = parseConfidence;
	}

	public List<Double> getOovConfidence() {
		return m_oovConfidence;
	}

	public void setOovConfidence(List<Double> oovConfidence) throws SentenceDataException {
		checkSize(oovConfidence);
		this.m_oovConfidence = oovConfidence;
	}
	
	public List<Double> getDuration() {
		return m_duration;
	}

	public void setDuration(List<Double> duration) throws SentenceDataException {
		checkSize(duration);
		this.m_duration = duration;
	}

	public List<Double> getNeConfidence() {
		return m_neConfidence;
	}

	public void setNeConfidence(List<Double> neConfidence) throws SentenceDataException {
		checkSize(neConfidence);
		this.m_neConfidence = neConfidence;
	}
	
	/**
	 * return true if there are content words before the start of this error
	 * @return
	 */
	public boolean hasContentWordsBeforeCurrentError()
	{
		for(int i = 0; i < getCurrentlyAddressedErrorSegment().getM_start(); i++)
		{
			if(NLPutil.getInstance().isContentPOS(m_postagsWorkingUtt.get(i)))
				return true;
		}
		//if none of the POS tags is content
		return false;
		
	}
	
	/**
	 * return true if there are errors preceeding this error
	 * @return
	 */
	public boolean hasErrorBeforeCurrentError()
	{
		if(m_addressErrorSegmentIndex>0) 
			return true;
		return false;
	}
	
	/**
	 * return true if there are errors following this error
	 * @return
	 */
	public boolean hasErrorAfterCurrentError()
	{
		if(m_addressErrorSegmentIndex==errorSegmentsFromAMU.size()-1) 
			return true;
		return false;
	}

	/**
	 * return all words until the error number index
	 * @param index
	 * @return
	 */	
	public String getWorkingHypothesisBeforeError(int index) {
		ErrorSegment errseg = errorSegmentsFromAMU.get(index);
		
		String retstr = new String();
		for (int i = 0; i< errseg.getM_start(); i++)
		{
			retstr += m_wordsWorkingUtt.get(i) + " ";
		}
		
		return retstr;
	}
	
	

	/**
	 * return all words after the error number index
	 * @param index
	 * @return
	 */	
	public String getWorkingHypothesisAfterError(int index) {
		ErrorSegment errseg = errorSegmentsFromAMU.get(index);
		
		String retstr = new String();
		for (int i = errseg.getM_end()+1; i<m_wordsWorkingUtt.size(); i++)
		{
			retstr += m_wordsWorkingUtt.get(i) + " ";
		}
		
		return retstr;
	}
	
	/**
	 * 
	 * @return true if the input indicates quit
	 */
	public boolean isQuit()
	{
		if(m_asrHypothesis.equals("q"))
		    return true;
		else
			return false;
	}

	public String printInput() {
	   String returnVal = "in:" + m_asrHypothesis;
	   returnVal += "#ErrorSeg=" + errorSegmentsFromAMU.size();
	   //returnVal += "MergeConf=" + m_confMerger;
	   for (ErrorSegment errSeg: errorSegmentsFromAMU) {
	      returnVal += "["+ errSeg.toString() + "]";
	   }
	   
	   return returnVal;
	}

	public String printOutput() {
		
		if(m_dmEntry==null) return "out: NONE";
		return m_dmEntry.toString();
	}

	
	@Override
	public String toString()
	{
		return printInput() + "; " + printOutput();
		
	}

	public void setAsrHypothesis(String asrHypothesis) {
		this.m_asrHypothesis = asrHypothesis;
	}

	public String getAsrHypothesis() {
		// TODO Auto-generated method stub
		return m_asrHypothesis;
	}

	public DialogueEntry getDmEntry() {
		return m_dmEntry;
	}

	public void setDmEntry(DialogueEntry dmEntry) {
		this.m_dmEntry = dmEntry;
	}
	
	public List<Double> getcfConfidence() {
		return m_cfConfidence;
	}

	public void setcfConfidence(List<Double> cfConfidence) {
		this.m_cfConfidence = cfConfidence;
	}
	
	public void setUttConfidence(Double confidence){
		this.m_uttConfidence = confidence;
	}
	
	public Double getUttConfidence(){
		return m_uttConfidence;
	}
	
	public void setProsodicsForWords(List<Double> f0max, List<Double> f0min, List<Double> f0mean, List<Double> f0stdev,
							 List<Double> engmax, List<Double> engmin, List<Double> engmean, List<Double> engstdev, List<Double> vcd2tot) 
		throws SentenceDataException {
		
		checkSize(f0max);
		checkSize(f0min);
		checkSize(f0mean);
		checkSize(f0stdev);
		checkSize(engmax);
		checkSize(engmin);
		checkSize(engmean);
		checkSize(engstdev);
		checkSize(vcd2tot);

		m_prosodicswords.setProsodicsForWords(f0max, f0min, f0mean, f0stdev, engmax, engmin, engmean, engstdev, vcd2tot);
	}
	
	public void setProsodicsForUtterance(Double f0max, Double f0min, Double f0mean, Double f0stdev, 
											Double engmax, Double engmin, Double engmean, Double engstdev, Double vcd2tot) {

		m_prosodicsutt.setProsodicsForUtterance(f0max, f0min, f0stdev, f0mean, engmax, engmin, engmean, engstdev, vcd2tot);
	}
	
	public List<Double> getF0maxWords() {
		return m_prosodicswords.getF0max();
	}
	
	public List<Double> getF0minWords() {
		return m_prosodicswords.getF0min();
	}
	
	public List<Double> getF0meanWords() {
		return m_prosodicswords.getF0mean();
	}
	
	public List<Double> getF0stdevWords() {
		return m_prosodicswords.getF0stdev();
	}
	
	public List<Double> getEngmaxWords() {
		return m_prosodicswords.getEngmax();		
	}
	
	public List<Double> getEngminWords() {
		return m_prosodicswords.getEngmin();
	}
	
	public List<Double> getEngmeanWords() {
		return m_prosodicswords.getEngmean();
	}
	
	public List<Double> getEngstdevWords() {
		return m_prosodicswords.getEngstdev();
	}
	
	public List<Double> getVcd2totWords() {
		return m_prosodicswords.getVcd2tot();
	}
	
	public List<Double> getF0maxUtterance() {
		return m_prosodicsutt.getF0max();
	}
	
	public List<Double> getF0minUtterance() {
		return m_prosodicsutt.getF0min();
	}
	
	public List<Double> getF0meanUtterance() {
		return m_prosodicsutt.getF0mean();
	}
	
	public List<Double> getF0stdevUtterance() {
		return m_prosodicsutt.getF0stdev();
	}
	
	public List<Double> getEngmaxUtterance() {
		return m_prosodicsutt.getEngmax();
	}
	
	public List<Double> getEngmiUtterance() {
		return m_prosodicsutt.getEngmin();
	}
	
	public List<Double> getEngmeanUtterance() {
		return m_prosodicsutt.getEngmean();
	}
	
	public List<Double> getEngstdevUtterance() {
		return m_prosodicsutt.getEngstdev();
	}
	
	public List<Double> getVcd2totUtterance() {
		return m_prosodicsutt.getVcd2tot();
	}
	

	public List<ErrorSegment> getErrorSegmentsFromAMU() {
		return errorSegmentsFromAMU;
	}

	public void setErrorSegmentsFromAMU(List<ErrorSegment> errorSegmentsFromAMU) {
		this.errorSegmentsFromAMU = errorSegmentsFromAMU;
	}	
	
	public DialogueHistory getM_dialogHistory() {
			return m_dialogHistory;
	}
		
	public void addToHistory(SentenceData histData) {
			this.m_dialogHistory.add(histData);
	}	
	
	public int getM_addressErrorSegmentIndex() {
			return m_addressErrorSegmentIndex;
	}
		
	public void setM_addressErrorSegmentIndex(int m_addressErrorSegmentIndex) {
		m_log.print(1, "Addressing error #" + m_addressErrorSegmentIndex);
			this.m_addressErrorSegmentIndex = m_addressErrorSegmentIndex;
	}


	public ErrorSegment.UserFeedback getUserFeedbackUtt() {
		return userActionYesNo;
	}

	public void setUserFeedbackUtt(ErrorSegment.UserFeedback userFeedbackUtt) {
		this.userActionYesNo = userFeedbackUtt;
	}


	public String getWorkingHypothesis() {
		return m_workingHypothesis;
	}

	public void setWorkingHypothesis(String m_mergedHypothesis) {
		this.m_workingHypothesis = m_mergedHypothesis;
	}

	public AnswerMergerOperationType getAnswerMergerOperationType() {
		return answerMergerOperationType;
	}

	public void setAnswerMergerOperationType(
			AnswerMergerOperationType answerMergerOperationType) {
		this.answerMergerOperationType = answerMergerOperationType;
	}

	public Boolean getUserActionGoBack() {
		return userActionGoBack;
	}


	public List<Integer> getPointerUtteranceIndex() {
		return pointerUtteranceIndexWorkUtt;
	}

	public void setPointerUtteranceAndWordIndex(List<Integer> pointerUtteranceIndex, 
			List<Integer> pointerWordIndex) throws SentenceDataException{
		
		int workingHypLength = m_workingHypothesis.split(" ").length;
		if(workingHypLength != pointerUtteranceIndex.size() || 
				workingHypLength != pointerWordIndex.size() )
			throw new SentenceDataException("length of the pointers is not the same as the merged_utterance");
		
		this.pointerUtteranceIndexWorkUtt = pointerUtteranceIndex;
		this.pointerWordIndexWorkUtt = pointerWordIndex;
		
	}

	public void setUserActionGoBack(Boolean userActionGoBack) {
		this.userActionGoBack = userActionGoBack;
	}

	public List<String> getM_postagsWorkingUtt() {
		return m_postagsWorkingUtt;
	}

	public void setM_postagsWorkingUtt(List<String> mPostagsWorkingUtt) {
		m_postagsWorkingUtt = mPostagsWorkingUtt;
	}

	public void setM_dialogHistory(DialogueHistory mDialogHistory) {
		m_dialogHistory = mDialogHistory;
	}

	public List<String> getM_wordsWorkingUtt() {
		return m_wordsWorkingUtt;
	}

	public void setM_wordsWorkingUtt(List<String> mWordsWorkingUtt) {
		m_wordsWorkingUtt = mWordsWorkingUtt;
	}


	
  

}
